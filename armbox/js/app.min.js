let renderer, scene, camera, cameraCtrl;
let width, height, cx, cy, wWidth, wHeight;
const TMath = THREE.Math;

let conf = {
    color: 0xFF0000,
    objectWidth: 12,
    objectThickness: 3,
    ambientColor: 0xffffff,
    light1Color: 0xffffff,
    shadow: false,
    perspective: 75,
    cameraZ: 75,
};

let objects = [];
let geometry, material;
let hMap, hMap0, nx, ny;

init();

function init() {
    renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('reveal-effect'), antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera(conf.perspective, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = conf.cameraZ;

    scene = new THREE.Scene();
    geometry = new THREE.BoxGeometry(conf.objectWidth, conf.objectWidth, conf.objectThickness);

    window.addEventListener('load', initScene);
    document.getElementById('trigger').addEventListener('click', initScene);

    animate();
};

function initScene() {
    onResize();
    scene = new THREE.Scene();
    initLights();
    initObjects();
}

function initLights() {
    scene.add(new THREE.AmbientLight(conf.ambientColor));
    let light = new THREE.PointLight(0xffffff);
    light.position.z = 100;
    scene.add(light);
}

function initObjects() {
    objects = [];
    nx = Math.round(wWidth / conf.objectWidth) + 1;
    ny = Math.round(wHeight / conf.objectWidth) + 1;
    let mesh, x, y;
    for (let i = 0; i < nx; i++) {
        for (let j = 0; j < ny; j++) {
            material = new THREE.MeshLambertMaterial({ color: conf.color, transparent: true, opacity: 1 });
            mesh = new THREE.Mesh(geometry, material);
            x = -wWidth / 2 + i * conf.objectWidth;
            y = -wHeight / 2 + j * conf.objectWidth;
            mesh.position.set(x, y, 0);
            objects.push(mesh);
            scene.add(mesh);
        }
    }
    document.body.classList.add('loaded');
    startAnim();
}

function startAnim() {
    document.body.classList.remove('revealed');
    objects.forEach(mesh => {
        mesh.rotation.set(0, 0, 0);
        mesh.material.opacity = 1;
        mesh.position.z = 0;
        let delay = TMath.randFloat(1, 2);
        let rx = TMath.randFloatSpread(2 * Math.PI);
        let ry = TMath.randFloatSpread(2 * Math.PI);
        let rz = TMath.randFloatSpread(2 * Math.PI);
        TweenMax.to(mesh.rotation, 2, { x: rx, y: ry, z: rz, delay: delay });
        TweenMax.to(mesh.position, 2, { z: 80, delay: delay + 0.5, ease: Power1.easeOut });
        TweenMax.to(mesh.material, 2, { opacity: 0, delay: delay + 0.5 });
    });
    setTimeout(() => {
        document.body.classList.add('revealed');
    }, 4500);
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
};

function onResize() {
    width = window.innerWidth; cx = width / 2;
    height = window.innerHeight; cy = height / 2;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);

    size = getRendererSize();
    wWidth = size[0];
    wHeight = size[1];
}

function getRendererSize() {
    const cam = new THREE.PerspectiveCamera(conf.perspective, camera.aspect);
    const vFOV = cam.fov * Math.PI / 180;
    const height = 2 * Math.tan(vFOV / 2) * Math.abs(conf.cameraZ);
    const width = height * cam.aspect;
    return [width, height];
}



let b = 0
let mainAnim = document.getElementById("main-anim")
let animItem = document.getElementById("main__search-item")
let images = ["clement-m-0vOoWtDiKXY-unsplash 1.png", "e192d530777373.56323336b1cf2.jpg", "Mask group (1).png",]
mainAnim?.addEventListener("mousemove", (e) => {
    b++
    animItem.style.left = e.offsetX + "px";
    animItem.style.top = e.offsetY + "px";
    if (b > 150) {
        b = 0;
        animItem.children[0].setAttribute("src", "img/" + images[Math.floor(Math.random() * (images.length + 1))] + "")
    }
})

let textTop = document.getElementById("textSlideTop")
let textBottom = document.getElementById("textSlideBottom")
let header = document.getElementById("header")
let subscription = document.getElementById("subscription")
let animStart = 0
let subscriptionItem = document.getElementsByClassName("subscription__item")
let boxItem = document.getElementsByClassName("box")
let roate = 0
let animEtap = 0
let setCanvas = 0
let bonusBgSize = 100
let newScroll = 0
let bonuseBox = document.getElementById("bonuse__bg")
window.onload = function () {
    window.scroll({
        top: 0,
        left: 0,
        behavior: 'smooth'
    });
}
window.addEventListener('scroll', () => {
    let { scrollY } = window
    textTop.style.left = (scrollY - (textTop.offsetTop - 200)) + "px"
    textBottom.style.right = (scrollY - (textBottom.offsetTop - 200)) + "px"
    if (scrollY > subscription.offsetTop - 100 && animEtap === 0) {
        animEtap = 1
        document.getElementById("subscription-anim").style.transform = "rotate(500deg)"
        subscriptionItem[0].style.transform = "translate(0)"
        subscriptionItem[1].style.transform = "translate(0)"
        subscriptionItem[2].style.transform = "translate(0)"
        boxItem[0].style.width = subscriptionItem[0].offsetLeft + "px"
        boxItem[2].style.width = subscription.offsetWidth - subscriptionItem[2].offsetLeft - subscriptionItem[2].offsetWidth + "px"
        boxItem[1].style.height = subscription.offsetHeight - subscriptionItem[1].offsetTop - subscriptionItem[1].offsetHeight + "px"
        setTimeout(() => {
            boxItem[0].style.width = "0px"
            boxItem[2].style.width = "0px"
            boxItem[1].style.height = "0px"
        }, 2000)
    }
    if (scrollY >= (subscription.offsetTop - header.offsetHeight) && animStart === 0) {
        window.scroll({
            top: subscription.offsetTop - header.offsetHeight,
            left: 0,
            behavior: 'smooth'
        });
        setTimeout(() => {
            animStart = 1
        }, 4000)
    }
})


